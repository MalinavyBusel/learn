Короче

Для начала репозиторий нужно создать
Это или git init и он создаст в текущей папке, или клонировать уже существующий через консоль (рис. 1)
Если клонировал, то он уже синхронизирован с гитхабовским, и если есть права, то можно уже работать с ним
Если сделал свой локально, то нужно создать пустой на гитхабе и отправить(запушить) свой туда, там когда создашь, то команды будут написаны



Главное - коммиты и ветки

коммит - сама по себе типа отдельная версия. Наверное еще можно сказать что это просто сохраненные изменения. Они имеют порядок, и каждый новый следует за предыдущим. Если накосячил, то можно отменить коммит, файлы вернутся в нужное состояние, но в истории он останется, и пометка о его отмене тоже. Прикол, что если закоммитал какой-ндь пароль, то хрен ты его уберешь, в истории изменения будут видны, если поискать.
Как делать коммиты:
 - сделал какие-то изменения, желательно логически связанные
 - нажал git stage ./путь_к_ним  //не помню, зачем stage, но это как-то связано с отслеживанием изменений, можешь читануть
 - git commit -m "кописание коммита" ./вроде_тоже_дальше_путь   //старайся подписывать коммиты по-человечески
 - все сохранилось, тебе покажет логи изменений
Гит отслеживает изменения только в тех файлах, которые в него добавили. То есть если ты заклонил, то все файлы уже отслеживаются. Если создал новый файл в папке репы, то он по умолчанию его не трекает. Чтобы добавить, пиши git add ./путь
Не все файлы ты хочешь отслеживать, если их не добавлять, то логи все равно засоряться немного будут, что вот, мол, добавьте файлы. Для этого есть .gitignore файлы. Почитай сам, там суть не сложная, но инфы многовато тут писать.

Ветка - типа независимая отдельная история коммитов, связный список коммитов наверное даже лучше. Ветки друг от друга не зависят, то есть поменял в одной, переключился на другую, и эта другая без изменений. Ветки можешь создавать сколько угодно, и как угодно между ними переключать
Переключить на другую ветку - git checkout ветка_name
Создать новую и сразу переключить на неё - git checkout -b ветка_name. При этом копируется история коммитов ветки, из которой ты создал это, но с этого момента истории у них разные, и состояние файлов тоже. В одной добавил А, в другой Б, переключаешься между ними, и гит сам меняет файлы к нужному состоянию. Поставил А-ветку - он удалил Б и добавил А, вернул опять Б-ветку - убрал код А и добавил Б.
Ветки делают в основном чтобы друг другу и самому себе не мешать и не путаться в коммитах и изменениях. Типа я делаю там класс котов, чел класс собак, каждый создал из главной себе по ветке и кодит там. Потом ветки объединяются.
Объединить ветки - ты в ветке А, есть ветка Б. Пишешь git merge Б - и все изменения ветки Б добавляются с историей коммитов в твою ветку А. 



Пулл, пуш и пулл-реквест

Пулл - ты скопировал к себе локально репу, но через неделю другой чел что-то поменял, и тебе нужно добавить свои изменения в этот код. Тогда 
пиши git push, по идее если репа синхронизирована, то гит сам все добавит, вроде даже сразу для всех веток, в том числе тех, которых у тебя пока локально нет.

git push - противоположность пуллу, ты отправляешь свои коммиты новые на сервер(гитхаб), чтобы они были видны при просмотре и остальные разработчики также могли их уже себе запулить

пулл-реквест - когда хочешь запушить изменения, но перед этим хочешь, чтобы их проверили твои коллеги и одобрили. Обычно вместе с новой созданной тобой веткой пушишь, точнее не с ней, а её. Может и в старой можно, но я так никогда не делал, а вот в новой постоянно. В чем прикол:
- создал локально новую ветку и в ней сделал коммиты важных изменений. 
- git push --set-upstream origin твоя_ветка_name  //пушишь её на гитхаб 
- заходишь на страницу проекта в гитхабе, и жмешь на зеленую кнопку на желтом фоне add pull request (рис 2)
- указываешь в какую ветку тебе мержить в случае принятия твою текущую пуллреквестовую, и выбираешь, кто должен чекнуть твой код (рис 3) ОБЫЧНО ЕСТЬ ДРУГИЕ ВЕТКИ КРОМЕ БАЗОВОЙ main, И РАЗРАБОТКА ИДЕТ В НИХ, А main ЧИСТО ДЛЯ РЕЛИЗОВ, НО ПО УМОЛЧАНЮ ДЛЯ МЕРЖА СТАВИТСЯ ОНА, НЕ ЗАБЫВАЙ ЕЕ МЕНЯТЬ НА НУЖНУЮ, ЧТОБЫ ПО ОШИБКЕ ТУДА НЕ ЗАЛИТЬ СВОЙ КОД РАНЬШЕ ВРЕМЕНИ.
-когда челы одобрили, проматываешь вниз и нажимаешь merge. Если не одобрили, то меняешь код и пушишь его той же веткой, новую делать не надо, и перезапрашиваешь одобрение в той же боковой панельке на значке стрелочек



Конфликты

Была начальная версия кода А. Ты создал Б, чел - С, оба из версии А. Он запушил раньше, ты пытаешься добавить свое, но не можешь. Почему? Потому что гит создал изменения из строки А в Б. Но там уже стоит строка С, а из С в Б он не знает как сделать, ибо ваши версии кода вне зависимости от времени могут быть одинаково правильными. Это и есть конфликт - когда несколько человек изменило код (в одном месте файла !!!), и гит не может выбрать нужный. Эта штука происходить либо когда ты в одной ветке забыл перед началом работы сделать пулл, добавил свои изменения, а на сервере в этом же месте их добавил кто-то другой(всегда старайся делать пулл перед кодингомЮ если не один пишешь); либо ты пытаешься смержить ветку, но изменения в ней пересекаются с другими в той, в которую ты мержишь, и тоже гит не знает какие правильные. Он обычно в файлах самих указывает стрелочками difference 
>>>>>>>>>
...
<<<<<<<<<
Можно руками поправить, но это сложно, интерфейс не оч для этого всего, плюс не факт, что еще чего не сломаешь в самом коде и оно работать не перестанет


Можешь еще почекать про:
git reset (--hard --soft ...) - !!!
тэги
cherry-pick
rebase
git log
git status
CODEOWNERS-файл
gitlab - альтернатива гитхабу
bitbucket - то же, чсто и гитлаб
git submodule - сам еще не юзал, незачем было, но типа некоторые говорят, что полезная вещь
